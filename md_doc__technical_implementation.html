<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ECSTASY: Technical Implementations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ECSTASY
   </div>
   <div id="projectbrief">All in the name</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_doc__technical_implementation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Technical Implementations </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Explore the inner workings and technical details of Ecstasy. Gain insights into the core concepts, queryable structures, modifiers, conditions, and delve into the intricacies of implementing and utilizing these features. This section provides a deeper understanding of the ECS architecture and serves as a valuable resource for developers looking to integrate and optimize their systems with Ecstasy.</p>
<h1><a class="anchor" id="autotoc_md35"></a>
Entities Management</h1>
<p>The <a class="el" href="classecstasy_1_1_entities.html">ecstasy::Entities</a> resource is the container of the registry entities informations. It is designed to be used within a registry and doesn't make sense alone. This resource only manage the <em>lifetime</em> of the entities. Meaning it only knows if an entity exist, if it is alive or killed etc... It has no knowledge about the entity components.</p>
<p>An entity is in fact only an identifier, an index, it doesn't really contains components. To keep track of the entities and their status, two <a class="el" href="classutil_1_1_bit_set.html">util::BitSet</a> and a <a class="elRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector</a> are used.</p>
<div class="fragment"><div class="line"><span class="comment">// Keep track of the entity generation at each index</span></div>
<div class="line"><span class="comment">// _generations[index] = generation of the current entity at the index</span></div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt;Entity::Generation&gt;</a> _generations;</div>
<div class="line"><span class="comment">// Keep tracks of all existing entities.</span></div>
<div class="line"><span class="comment">// _alive[index] = True (1) if the entity is alive, False (0) if not</span></div>
<div class="line"><a class="code" href="classutil_1_1_bit_set.html">util::BitSet</a> _alive;</div>
<div class="line"><span class="comment">// Keep tracks of the deletion markers.</span></div>
<div class="line"><span class="comment">// _killed[index] = True (1) if the entity needs to be killed, False(0) if not</span></div>
<div class="line"><a class="code" href="classutil_1_1_bit_set.html">util::BitSet</a> _killed;</div>
<div class="ttc" id="aclassutil_1_1_bit_set_html"><div class="ttname"><a href="classutil_1_1_bit_set.html">util::BitSet</a></div><div class="ttdoc">Mimics the API of std::bitset but with the dynamic properties of std::vector&lt;bool&gt;</div><div class="ttdef"><b>Definition:</b> <a href="_bit_set_8hpp_source.html#l00035">BitSet.hpp:35</a></div></div>
<div class="ttc" id="avector_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/vector.html">std::vector&lt; Entity::Generation &gt;</a></div></div>
</div><!-- fragment --><ol type="1">
<li><p class="startli">Initialisation</p>
<p class="startli">The <a class="el" href="classecstasy_1_1_entities.html">ecstasy::Entities</a> resource is initialized with a sentinel bit is set at the end of the bitsets, therefore they are never empty.</p>
</li>
<li><p class="startli">Entity creation (<a class="el" href="classecstasy_1_1_entities.html#af64aafed2e3a93054537b93b92e5f86a">ecstasy::Entities::create</a>)</p>
<p class="startli">A new bit is appended to the _alive bitset, representing the new entity. If there is a killed entity in the bitset, takes this place instead of resizing the bitset.</p>
</li>
<li><p class="startli">Entity deletion (<a class="el" href="classecstasy_1_1_entities.html#a8ab0b16f21e56cbdc4f773e35a634077">ecstasy::Entities::erase</a>)</p>
<p class="startli">Erasing an entity just means setting the bit at its index to false in _alive bitset. The deletion is instant.</p>
</li>
<li><p class="startli">Entity kill (<a class="el" href="classecstasy_1_1_entities.html#a5b5ee10b59fdbd21568254ad57903755">ecstasy::Entities::kill</a>)</p>
<p class="startli">Killing an entity does not erase the entity, it only marks it for deletion. It set the bit at the entity index to true in _killed bitset. If the bitset is too small, it is resize appropriately before. To effectively delete the killed entities, you need to call <a class="el" href="classecstasy_1_1_entities.html#ae6313ea1ae99037aaf335034d66e5e45">ecstasy::Entities::maintain</a>.</p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md36"></a>
Components Management (MapStorage)</h1>
<p>Components management is made through the <a class="el" href="classecstasy_1_1_i_storage.html">ecstasy::IStorage</a>. You can implement your own storage but the default storage is the <a class="el" href="classecstasy_1_1_map_storage.html">ecstasy::MapStorage</a> and this part will only talk about it.</p>
<p>The MapStorage keep tracks of the components using two members:</p>
<div class="fragment"><div class="line"><span class="comment">// Component container, keeps data associated with the entity at the given index (bitset index)</span></div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt;Entity::Index, Component&gt;</a> _components;</div>
<div class="line"><span class="comment">// BitSet for a fast access on entity having or not the component (bit set to 1 means the entity at the bit index has the component)</span></div>
<div class="line"><a class="code" href="classutil_1_1_bit_set.html">util::BitSet</a> _mask;</div>
<div class="ttc" id="aunordered_map_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/container/unordered_map.html">std::unordered_map&lt; Entity::Index, Component &gt;</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md37"></a>
Query</h1>
<p>The query implementation is mostly in the <b><a class="el" href="namespaceecstasy_1_1query.html" title="Namespace regrouping the internal ecstasy query system.">ecstasy::query</a></b> namespace. It rely on <b>Queryable</b>, <b>Conditions</b> and mostly on <b>BitSet</b>. The registry have some query code too, mostly to fetch the queryables from the registry storages or resources. But the query class can be used without the registry parts if you provide the queryables yourself. Meaning the query system could be extracted to be used in another context with some work.</p>
<p>So how does the query work behind the scene of the template black magic ?</p>
<p>To simplify things I will start to explains with the internal <b><a class="el" href="namespaceecstasy_1_1query.html" title="Namespace regrouping the internal ecstasy query system.">ecstasy::query</a></b> behavior and then explain the autolinks on the registry.</p>
<p>If you read the Entity/Component parts I talked about the <a class="el" href="classutil_1_1_bit_set.html">util::BitSet</a> class. The query operates on bitsets. When you query all entities with the component position and velocity, 3 bitsets are sent to the query.</p>
<ul>
<li>Entities Bitset (_alive)</li>
<li>Position storage bitset (_mask)</li>
<li>Velocity storage bitset (_mask)</li>
</ul>
<p>The query can then perform a simple bitwise <code>and</code> on all the bitset and has its final bitset. When you query the registry, the bitset is computed only upon creation and you iterate on the computed bitset. Then for each bit set, the query fetch the associated component in the position/velocity storage.</p>
<h3><a class="anchor" id="autotoc_md38"></a>
Queryable and BitSet</h3>
<p>A storage is in fact a <a class="el" href="namespaceecstasy_1_1query.html#aef33b329c1a412eb7f7403b90881d468">ecstasy::query::Queryable</a>. It is defined by three properties:</p>
<ul>
<li>A bitset, accessible through a <code>getMask()</code> method</li>
<li>A type for the value to return on iteration, defined as a nested <code>QueryData</code> type</li>
<li>A method <code>getQueryData()</code> to fetch the value on iteration</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Q&gt;</div>
<div class="line">concept <a class="code" href="namespaceecstasy_1_1query.html#aef33b329c1a412eb7f7403b90881d468">Queryable</a> = <a class="code" href="namespaceecstasy_1_1query.html#aae5d7b89c92ec00ebea0cf94b09d8087">requires</a>(Q &amp;queryable, Q <span class="keyword">const</span> &amp;cqueryable, <a class="codeRef" href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a> index)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typename</span> Q::QueryData;</div>
<div class="line"> </div>
<div class="line">    { cqueryable.getMask() } -&gt; std::same_as&lt;util::BitSet const &amp;&gt;;</div>
<div class="line"> </div>
<div class="line">    { queryable.getQueryData(index) } -&gt; std::same_as&lt;typename Q::QueryData&gt;;</div>
<div class="line">};</div>
<div class="ttc" id="anamespaceecstasy_1_1query_html_aae5d7b89c92ec00ebea0cf94b09d8087"><div class="ttname"><a href="namespaceecstasy_1_1query.html#aae5d7b89c92ec00ebea0cf94b09d8087">ecstasy::query::requires</a></div><div class="ttdeci">requires(!std::is_member_pointer_v&lt; LeftType &gt; &amp;&amp;!std::is_member_pointer_v&lt; RightType &gt;) struct Condition&lt; Left</div></div>
<div class="ttc" id="anamespaceecstasy_1_1query_html_aef33b329c1a412eb7f7403b90881d468"><div class="ttname"><a href="namespaceecstasy_1_1query.html#aef33b329c1a412eb7f7403b90881d468">ecstasy::query::Queryable</a></div><div class="ttdeci">concept Queryable</div><div class="ttdoc">Defines a type that can be queried.</div><div class="ttdef"><b>Definition:</b> <a href="_queryable_8hpp_source.html#l00124">Queryable.hpp:124</a></div></div>
<div class="ttc" id="asize_t_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/types/size_t.html">std::size_t</a></div></div>
</div><!-- fragment --><p>Knowing this I can re explain the query behavior. The query takes only <a class="el" href="namespaceecstasy_1_1query.html#aef33b329c1a412eb7f7403b90881d468">ecstasy::query::Queryable</a> in inputs. It then does a bitwise <code>and</code> on the associated bitsets and save it. The class also defines an iterator to... iterate on the matching entities and on each match it returns a tuple of the values, fetched through the <code>getQueryData</code> method.</p>
<p>You can also create a Query with a precomputed bitset as you can see below with the first constructor.</p>
<p><em><a class="el" href="namespaceutil_1_1meta.html" title="Namespace regrouping all meta programmation helper types.">util::meta</a>::* are helpers meta programming "functions"/types</em></p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<a class="code" href="namespaceecstasy_1_1query.html#aef33b329c1a412eb7f7403b90881d468">Queryable</a> First, <a class="code" href="namespaceecstasy_1_1query.html#aef33b329c1a412eb7f7403b90881d468">Queryable</a>... Others&gt;</div>
<div class="line"><span class="keyword">class </span>Query : <span class="keyword">public</span> QueryImplementation&lt;util::meta::Traits&lt;First, Others...&gt;, util::meta::Traits&lt;&gt;&gt; {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Construct a query with a precomputed bitset. Storages are still required to access the values.</span></div>
<div class="line">    Query(<a class="code" href="classutil_1_1_bit_set.html">util::BitSet</a> &amp;mask, <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple&lt;First &amp;, Others &amp;...&gt;</a> &amp;storages)</div>
<div class="line">        : QueryImplementation&lt;<a class="code" href="namespaceutil.html">util</a>::meta::Traits&lt;First, Others...&gt;, <a class="code" href="namespaceutil.html">util</a>::meta::Traits&lt;&gt;&gt;(mask, storages)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Construct a query from multiple queryables</span></div>
<div class="line">    Query(First &amp;first, Others &amp;...others)</div>
<div class="line">        : QueryImplementation&lt;<a class="code" href="namespaceutil.html">util</a>::meta::Traits&lt;First, Others...&gt;, <a class="code" href="namespaceutil.html">util</a>::meta::Traits&lt;&gt;&gt;(</div>
<div class="line">            first, <a class="codeRef" href="http://en.cppreference.com/w/namespacestd.html">std</a>::<a class="codeRef" href="http://en.cppreference.com/w/cpp/utility/forward.html">forward</a>&lt;Others &amp;&gt;(others)...)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="aforward_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/forward.html">std::forward</a></div><div class="ttdeci">T forward(T... args)</div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="http://en.cppreference.com/w/namespacestd.html">std</a></div></div>
<div class="ttc" id="anamespaceutil_html"><div class="ttname"><a href="namespaceutil.html">util</a></div><div class="ttdoc">Namespace regrouping helpers used by ecstasy but not specific to ecstasy.</div><div class="ttdef"><b>Definition:</b> <a href="_queryable_8hpp_source.html#l00020">Queryable.hpp:21</a></div></div>
<div class="ttc" id="atuple_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/utility/tuple.html">std::tuple</a></div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md39"></a>
Registry basic query</h3>
<p>As we seen before, the <a class="el" href="classecstasy_1_1query_1_1_query.html">ecstasy::query::Query</a> needs queryables. But we don't send any in the registry query:</p>
<div class="fragment"><div class="line">registry.query&lt;Position, Velocity&gt;()</div>
</div><!-- fragment --><p>Because magic happens in the registry, all the storages or resources are fetched with the <a class="el" href="classecstasy_1_1_registry.html#a2dffc7d9ba7876e21768949df1717a39">ecstasy::Registry::getQueryable</a> template method:</p>
<div class="fragment"><div class="line"><span class="comment">// Don&#39;t take in account the allocator, it is for next steps</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Cs, <span class="keyword">typename</span> A = <a class="code" href="namespaceecstasy.html#a23178e0869471d2ea8fbce5de4c2499b">ModifiersAllocator</a>&gt;</div>
<div class="line">query::Query&lt;queryable_type_t&lt;C&gt;, queryable_type_t&lt;Cs&gt;...&gt; query(OptionalModifiersAllocator&lt;A&gt; allocator)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> query::Query(getQueryable&lt;C&gt;(allocator), getQueryable&lt;Cs&gt;(allocator)...);</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceecstasy_html_a23178e0869471d2ea8fbce5de4c2499b"><div class="ttname"><a href="namespaceecstasy.html#a23178e0869471d2ea8fbce5de4c2499b">ecstasy::ModifiersAllocator</a></div><div class="ttdeci">util::Allocator&lt; ecstasy::query::modifier::ModifierBase &gt; ModifiersAllocator</div><div class="ttdef"><b>Definition:</b> <a href="_registry_8hpp_source.html#l00047">Registry.hpp:47</a></div></div>
</div><!-- fragment --><p>The following functionnalities (modifiers, conditions etc) respect the the zero-overhead C++ principle meaning if you don't use them it won't slow down your application.</p>
<h3><a class="anchor" id="autotoc_md40"></a>
Select where</h3>
<p>We already have almost everything to implement the select where syntax. These are the steps of resolution of the query:</p>
<ul>
<li>Detect the missing queryables in the where clause (everything in select must be in where clause too)</li>
<li>Fetch all the queryables from the registry</li>
<li>Compute the query mask with the where queryables</li>
<li>Construct our query with the precomputed mask and our selected queryables</li>
</ul>
<p>The hardest part is the first step, we already have the others. This basically means doing a left outer join to find the queryables present in the select clause (left) but not in the where clause (right). This was a nightmare to do and I can't explain better than the documented code so go see <a class="el" href="structecstasy_1_1query_1_1_select.html">ecstasy::query::Select</a> and <a class="el" href="classecstasy_1_1_registry_1_1_select.html">ecstasy::Registry::Select</a> classes as long as the <a class="el" href="namespaceutil_1_1meta.html">util::meta</a> namespace (<a class="el" href="structutil_1_1meta_1_1left__outer__join.html">util::meta::left_outer_join</a>).</p>
<h3><a class="anchor" id="autotoc_md41"></a>
Modifiers</h3>
<p>Modifiers are not complicated themselves. In fact they are only queryable wrappers. The easier example is the Maybe. What does it means to query <code>registry.query&lt;Maybe&lt;Position&gt;&gt;</code> ?</p>
<p>It means querying <code>Position</code>. But having all bit sets. And not returning a <code>Position</code> but a <code><a class="elRef" href="http://en.cppreference.com/w/cpp/utility/optional.html">std::optional</a>&lt;Position&gt;</code>. Finally a Modifier is really a Queryable, returning a bitset and a query data. See <a class="el" href="classecstasy_1_1query_1_1modifier_1_1_maybe.html">ecstasy::query::modifier::Maybe</a> implementation for more details.</p>
<p>The hard part about the modifiers is not their implementation but their allocation. Usual queryables are allocated by the registry and stored in the registry. Modifiers should be allocated only for the query lifetime. And we need to allocate data to store the wrapped queryable (example <b>Position</b> storage) and eventually the computed mask if there is one.</p>
<p>And because allocations means allocator, every registry query method can take an Allocator. First a heap allocator was used (<a class="el" href="namespaceecstasy.html#a23178e0869471d2ea8fbce5de4c2499b">ecstasy::ModifiersAllocator</a>) and was required if there was at least one modifier to allocate in the query and it raised an exception otherwise. But now you don't need to take care of it. I already did it for you. The modifiers are now allocated on the stack because the required size is known at compile time.</p>
<p>This magic hidden stack allocator use multiple inheritance black magic tricks and you can find more about it in <a class="el" href="classecstasy_1_1_registry_1_1_registry_stack_query.html">ecstasy::Registry::RegistryStackQuery</a>.</p>
<h3><a class="anchor" id="autotoc_md42"></a>
Conditions</h3>
<p>In opposite to modifiers, conditions are not queryable and doesn't use bitset either. The conditions are checked at runtime (because it check runtime values) on the query iteration.</p>
<p>Meaning if you iterate three times the same query the conditions will be evaluated three times for each matching entities. But the good part about it is that it check the condition only when the values are fetched and doesn't make an extra fetch just for the condition.</p>
<h3><a class="anchor" id="autotoc_md43"></a>
AutoLock</h3>
<p>The query parts have an <code>AutoLock</code> boolean template parameter. If it is set to true, it will wrap any queryables validating the <a class="el" href="namespaceecstasy_1_1thread.html#a3228b7205e71792e3a2f64a83579dc37">Lockable</a> concept in a <a class="el" href="classecstasy_1_1thread_1_1_lockable_view.html">LockableView</a>. This use the <a href="https://en.cppreference.com/w/cpp/language/raii">RAII</a> concept: wrapping the lockable in the views will lock them upon view construction and unlock them upon view destruction.</p>
<ol type="1">
<li><p class="startli">Make everything lockable</p>
<p class="startli">If you want thread safety, you need to be able to lock your storages and resources (especially Entities) otherwise they will never be locked.</p>
<p class="startli">For this you can use the compilation options <b>ECSTASY_LOCKABLE_RESOURCES</b> and/or <b>ECSTASY_LOCKABLE_STORAGES</b>. It will make the Resources and/or IStorage inherit from <a class="el" href="classecstasy_1_1thread_1_1_shared_recursive_mutex.html">SharedRecursiveMutex</a>, thus validating the Lockable concept.</p>
<dl class="section note"><dt>Note</dt><dd>This is disabled by default to avoid memory overhead of the mutex fields (ie: Zero-overhead principle).</dd></dl>
<p>If you want to set the <code>AutoLock</code> to true by default for every <b>registry</b> queries, you can compile ecstasy with <b>ECSTASY_AUTO_LOCK</b> option.</p>
</li>
<li><p class="startli">Skeptical Lock Mechanism (ie: <a class="el" href="classecstasy_1_1thread_1_1_shared_recursive_mutex.html">SharedRecursiveMutex</a>)</p>
<p class="startli">The <a class="el" href="classecstasy_1_1thread_1_1_shared_recursive_mutex.html">SharedRecursiveMutex</a> (SRM, too loong to write) is made in a way to be Lockable either with or without the const qualifier but the behavior will change:</p><ul>
<li>Calling <code>lock()</code>/<code>unlock()</code> on a non-const SRM will perform an <b>exclusive lock/unlock on the mutex</b></li>
<li>Calling <code>lock()</code>/<code>unlock()</code> on a const SRM will perform a <b>shared lock/unlock on the mutex</b></li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The mutex is recursive mostly because it is hard for ecstasy (meaning for my little brain) to detect whether a queryable is already locked by the current query or not, especially when dealing with the same queryable multiple times in the same query because of modifiers. Therefore it will be locked multiple times by the same query.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>As said above the same lockable can be locked multiple times by the same query. You can easily have a deadlock if in the same query you request a const queryable and the non const version. Because it will try to perform an exclusive lock and a shared lock, which are not compatible. See <a class="el" href="classecstasy_1_1thread_1_1_shared_recursive_mutex.html">SharedRecursiveMutex</a> documentation.</dd></dl>
</li>
<li><p class="startli"><a class="el" href="classecstasy_1_1thread_1_1_lockable_view.html">LockableView</a> instanciation</p>
<p class="startli"><a class="el" href="classecstasy_1_1thread_1_1_lockable_view.html">LockableView</a> (LV, I'm not too lazy for this parenthesis but too lazy to write <a class="el" href="classecstasy_1_1thread_1_1_lockable_view.html">LockableView</a>) can be instanciated at multiple times depending of the query.</p><ol type="a">
<li><p class="startli">In the Query itself</p>
<p class="startli">If you set <b>AutoLock</b> to true in the <a class="el" href="classecstasy_1_1query_1_1_query_implementation.html">QueryImplementation</a> the query will take the queryables references as inputs as usual. However it will store them in an LV using implicit constructor, because LV takes a reference to the lockable in constructor. Therefore the lifetime of the LV will be bound to the query.</p>
</li>
<li><p class="startli">In the registry stack query</p>
<p class="startli">However as you can guess it does not work well for precomputed mask like in the select where syntax because in these cases the query only keep the mask and the selected queryables, the where queryables are not kept in the query.</p>
<p class="startli">Therefore when doing query from the registry, the registry use the magical <a class="el" href="classecstasy_1_1_registry_1_1_registry_stack_query_memory.html">RegistryStackQueryMemory</a> class. This class compute the required size for the LVs and for the modifiers to allocate them on the stack (because why allocate on the heap when you can know at compile time the required memory size ?). The LV lifetime is the same as the RegistryStackQueryMemory, which is the same as the <a class="el" href="classecstasy_1_1_registry_1_1_registry_stack_query.html">RegistryStackQuery</a> (being the query).</p>
</li>
<li><p class="startli">And the modifiers ?</p>
<p class="startli">The modifiers also have an <b>AutoLock</b> template parameters. If it it set it works exactly as the QueryImplementation: it locks the queryables upon construction using implicit LV constructor.</p>
<dl class="section note"><dt>Note</dt><dd>By default the RegistryModifiers AutoLock value will be set from <b>ECSTASY_AUTO_LOCK</b> but you can use the extended version if you want to set/unset only one (AndEx, OrEx, XorEx , the Maybe and Not don't have extended version because the classic version already supports a second AutoLock parameter).</dd></dl>
</li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md44"></a>
Resolution Order</h3>
<p>We have seen everything, not in the lowest details but enough to understand most of the query behaviors. Here is the resolution order of all those functionnality.</p>
<p><b>Compile Time</b></p>
<ul>
<li>Detect missing Queryables in where clause from select clause</li>
<li>If no allocator provided prepare place in the stack with the appropriate size</li>
</ul>
<p><b>Query construction</b></p>
<ul>
<li>Fetch required queryables from registry (where and select clause)</li>
<li>Allocate required modifiers and views with the given allocator (which is by default the stack allocator)</li>
<li>Compute query bitset from the where clause</li>
<li>Creates the query object from the computed bitset and the selected queryables</li>
</ul>
<p><b>Query iteration</b></p>
<ul>
<li>Fetch the values</li>
<li>Check the conditions if any</li>
<li>Return the values </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
